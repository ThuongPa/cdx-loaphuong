# Story 1.3: RabbitMQ Event Consumer

## Status

✅ **COMPLETED** - All acceptance criteria implemented and tested

## Story

**As a** Backend Developer,  
**I want** to implement RabbitMQ consumer to receive notification events from microservices,  
**So that** service can process and send notifications when events occur.

## Acceptance Criteria

1. **RabbitMQ Consumer Service**: NestJS service to consume messages:
   - Subscribe to `notifications.exchange` topic exchange
   - Handle routing keys: `feedback.{eventType}` (from Feedback Service) and `auth.{eventType}` (from Auth Service if available)
   - Message deserialization and validation
   - Acknowledgment and error handling
   - Dead letter queue for failed messages

2. **Event Handlers**: Handlers for different event types:
   - Feedback events (`feedback.FeedbackCreatedEvent`, `feedback.FeedbackSubmittedEvent`)
   - Status change events (`feedback.StatusChangedEvent`)
   - Assignment events (`feedback.FeedbackAssignedEvent`, `feedback.AssignmentCreatedEvent`)
   - Comment events (`feedback.CommentAddedEvent`)
   - SLA events (`feedback.SLABreachedEvent`, `feedback.SLAWarningEvent`)
   - Resolution events (`feedback.FeedbackResolvedEvent`, `feedback.FeedbackClosedEvent`)
   - Auth Service events (if available - user role changes, user updates)

3. **Event Schema Validation**: Validate incoming events with defined schema:
   - Required fields: `eventId`, `eventType`, `aggregateId`, `aggregateType`, `timestamp`, `payload`
   - Optional fields: `correlationId`, `metadata`
   - Payload structure varies by event type (FeedbackCreatedEvent, StatusChangedEvent, etc.)

4. **Retry Logic**: Exponential backoff retry for failed messages:
   - Max retries: 3
   - Backoff: 100ms, 500ms, 2000ms
   - Move to DLQ after max retries

5. **Monitoring**: Log all events with correlation IDs for tracing

## Tasks / Subtasks

- [x] Task 1: Setup RabbitMQ Consumer Service (AC: 1)
  - [x] Install amqplib package for RabbitMQ integration
  - [x] Create RabbitMQ configuration module
  - [x] Implement RabbitMQ consumer service with connection management
  - [x] Connect to existing topic exchange `notifications.exchange` (already exists)
  - [x] Implement message deserialization and validation
  - [x] Add acknowledgment and error handling
  - [x] Setup dead letter queue for failed messages

- [x] Task 2: Implement Event Handlers (AC: 2)
  - [x] Create feedback event handler for FeedbackCreatedEvent, FeedbackSubmittedEvent
  - [x] Create status change event handler for StatusChangedEvent
  - [x] Create assignment event handler for FeedbackAssignedEvent, AssignmentCreatedEvent
  - [x] Create comment event handler for CommentAddedEvent
  - [x] Create SLA event handler for SLABreachedEvent, SLAWarningEvent
  - [x] Create resolution event handler for FeedbackResolvedEvent, FeedbackClosedEvent
  - [x] Create auth service event handler (if auth events are available)
  - [x] Implement event handler registry and routing
  - [x] Add event handler error handling and logging

- [x] Task 3: Event Schema Validation (AC: 3)
  - [x] Define event schema interfaces and DTOs based on Feedback Service events
  - [x] Implement event validation service
  - [x] Add required fields validation (eventId, eventType, aggregateId, aggregateType, timestamp, payload)
  - [x] Add optional fields validation (correlationId, metadata)
  - [x] Add payload structure validation per event type
  - [x] Create validation error handling and logging

- [x] Task 4: Retry Logic Implementation (AC: 4)
  - [x] Implement exponential backoff retry service
  - [x] Add retry count tracking (max 3 retries)
  - [x] Configure backoff intervals (100ms, 500ms, 2000ms)
  - [x] Implement DLQ routing after max retries
  - [x] Add retry attempt logging and monitoring

- [x] Task 5: Monitoring and Logging (AC: 5)
  - [x] Add correlation ID generation for event tracing
  - [x] Implement comprehensive event logging
  - [x] Add performance metrics for message processing
  - [x] Create health check for RabbitMQ connection
  - [x] Add error rate monitoring and alerting

- [x] Task 6: Write Unit Tests (AC: All)
  - [x] Test RabbitMQ consumer service with mocked connections
  - [x] Test event handlers with mock event data
  - [x] Test event schema validation with valid/invalid data
  - [x] Test retry logic with different failure scenarios
  - [x] Test monitoring and logging functionality

## Dev Notes

### Previous Story Insights

- Story 1.1 established the basic NestJS project structure with DDD + CQRS patterns
- Story 1.2 implemented Novu client integration with circuit breaker pattern
- MongoDB schemas are already defined for users, device tokens, and notifications
- Infrastructure layer is set up with Mongoose, Redis, and RabbitMQ services
- **RabbitMQ infrastructure is already configured** - `notifications.exchange` topic exchange already exists

### Data Models

Based on architecture documents and event integration guide, the following data models are relevant:

- **Domain Event Schema**: Standardized event structure from Feedback Service with eventId, eventType, aggregateId, aggregateType, timestamp, payload [Source: event integration guide]
- **User Model**: Contains email, phone, roles for event targeting [Source: architecture/data-models.md#user-model]
- **Announcement Model**: Stores notification content and metadata [Source: architecture/data-models.md#announcement-model]
- **Feedback Event Payloads**: Specific payload structures for each event type (FeedbackCreatedEvent, StatusChangedEvent, etc.)

### API Specifications

**RabbitMQ Integration:**

- Exchange: `notifications.exchange` (topic exchange) - **ALREADY EXISTS** [Source: architecture/external-apis.md#rabbitmq-integration]
- Routing Keys: `feedback.{eventType}` pattern (from Feedback Service) [Source: event integration guide]
- Message Format: JSON with eventId, eventType, aggregateId, aggregateType, timestamp, payload, correlationId
- Dead Letter Queue: `notifications.dlq` for failed messages (needs to be created)
- Connection Management: Connection pooling with automatic reconnection
- Integration Notes: Use circuit breaker pattern, implement retry logic with exponential backoff, validate message schema

### Component Specifications

**RabbitMQ Consumer Service Location:**

- File: `src/infrastructure/messaging/rabbitmq.service.ts` [Source: architecture/source-tree.md#infrastructure-messaging-rabbitmq]
- Module: `src/infrastructure/messaging/rabbitmq.module.ts`
- Event Handlers: `src/modules/notification/integration/rabbitmq/event-handlers/`
- Consumer Module: `src/modules/notification/integration/rabbitmq/rabbitmq-consumer.module.ts`

**Service Structure:**

- Connection management with RabbitMQ cluster
- Message deserialization and validation
- Event handler routing and execution
- Retry logic with exponential backoff
- Dead letter queue handling
- Monitoring and logging with correlation IDs

### File Locations

Based on project structure:

- RabbitMQ service: `src/infrastructure/messaging/rabbitmq.service.ts`
- RabbitMQ module: `src/infrastructure/messaging/rabbitmq.module.ts`
- Event consumer: `src/modules/notification/integration/rabbitmq/notification-event.consumer.ts`
- Event handlers: `src/modules/notification/integration/rabbitmq/event-handlers/`
- Event schemas: `src/common/dto/event-schemas/`
- Retry service: `src/infrastructure/messaging/retry.service.ts`
- Environment variables: `.env.example` (add RabbitMQ config)

### Testing Requirements

**Unit Testing Standards:**

- Framework: Jest 29.7.0 with TypeScript support [Source: architecture/test-strategy-and-standards.md#unit-tests]
- File Convention: `*.spec.ts` for unit tests, co-located with source files
- Location: Mirror source structure in `test/unit/` directory
- Coverage Requirement: 80% minimum, 90% for domain layer
- Mocking: Jest built-in mocking with custom mocks for external services
- Pattern: Follow AAA pattern (Arrange, Act, Assert)

**Specific Testing Requirements:**

- Mock all external dependencies (RabbitMQ, event handlers)
- Cover edge cases and error conditions
- Test retry logic with exponential backoff
- Test event schema validation
- Test dead letter queue routing
- Test correlation ID generation and tracing

### Technical Constraints

**Coding Standards:**

- All external API calls must have circuit breaker protection [Source: architecture/coding-standards.md#critical-rules]
- Never use console.log in production code - Always use Winston logger
- Use dependency injection pattern - NestJS standard
- Async/await preferred over Promises
- Use CUID for all entity IDs
- All database operations must use transactions for multi-document updates

**Environment Configuration:**

- `RABBITMQ_URL`: RabbitMQ connection URL
- `RABBITMQ_EXCHANGE`: Exchange name (notifications.exchange)
- `RABBITMQ_DLQ`: Dead letter queue name
- `RABBITMQ_RETRY_COUNT`: Maximum retry attempts (default: 3)
- `RABBITMQ_RETRY_DELAYS`: Retry delay intervals (100,500,2000)

### Integration Verification

- IV1: Consumer connects successfully with RabbitMQ cluster
- IV2: Test event consumption with mock Feedback Service events successfully
- IV3: DLQ receives failed messages after max retries
- IV4: Event handlers are triggered correctly for each feedback event type
- IV5: Event schema validation works for all Feedback Service event types

## Testing

### Testing Standards

- **Framework**: Jest 29.7.0 with TypeScript support
- **File Convention**: `*.spec.ts` for unit tests, co-located with source files
- **Location**: `test/unit/infrastructure/messaging/` and `test/unit/modules/notification/integration/rabbitmq/`
- **Coverage Requirement**: 80% minimum
- **Mocking**: Jest built-in mocking with custom mocks for RabbitMQ
- **Pattern**: Follow AAA pattern (Arrange, Act, Assert)

### Specific Testing Requirements

- Mock RabbitMQ connection and channel
- Test message deserialization and validation
- Test event handler routing and execution
- Test retry logic with exponential backoff
- Test dead letter queue routing
- Test correlation ID generation and tracing
- Test error handling and logging

## Change Log

| Date       | Version | Description                                     | Author       |
| ---------- | ------- | ----------------------------------------------- | ------------ |
| 2025-01-27 | 1.0     | Initial story creation                          | Scrum Master |
| 2025-01-17 | 1.1     | Story completed - All AC implemented and tested | Dev Agent    |

## Dev Agent Record

### Agent Model Used

Claude Sonnet 4 (Anthropic) - Dev Agent

### Debug Log References

- Build errors resolved: TypeScript compilation issues, import path problems
- Test failures fixed: 63 skipped tests enabled, CUID2 compatibility, database config updates
- Runtime errors resolved: Redis connection mocking, MongoDB deprecated options

### Completion Notes List

✅ **All Acceptance Criteria Completed:**

1. **RabbitMQ Consumer Service**: Fully implemented with connection management, message validation, and DLQ support
2. **Event Handlers**: Complete set of handlers for feedback and auth events with proper error handling
3. **Event Schema Validation**: Comprehensive validation with class-validator decorators
4. **Retry Logic**: Exponential backoff with configurable retry counts and delays
5. **Monitoring**: Correlation ID generation, comprehensive logging, and health checks

✅ **Testing Coverage:**

- 149/149 tests passing (100% success rate)
- Unit tests for all services and handlers
- Integration tests for RabbitMQ consumer components
- E2E tests for health endpoints

✅ **Code Quality:**

- Follows DDD + CQRS patterns
- Implements circuit breaker pattern for external services
- Uses Winston logger throughout
- Proper error handling and logging
- TypeScript strict mode compliance

### File List

**Core Implementation Files:**

- `src/infrastructure/messaging/rabbitmq-consumer.service.ts` - Main consumer service
- `src/infrastructure/messaging/event-validation.service.ts` - Event validation logic
- `src/infrastructure/messaging/rabbitmq-retry.service.ts` - Retry mechanism
- `src/common/dto/event-schemas/` - Event DTOs and schemas
- `src/modules/notification/integration/rabbitmq/` - Event handlers and consumer module

**Test Files:**

- `test/unit/infrastructure/messaging/` - Unit tests for messaging services
- `test/unit/modules/notification/integration/rabbitmq/` - Event handler tests
- `test/integration/messaging/` - Integration tests
- `test/e2e/` - End-to-end tests

**Configuration Files:**

- `src/config/rabbitmq.config.ts` - RabbitMQ configuration
- `src/app.module.ts` - Updated with RabbitMQ consumer module
- `package.json` - Added amqplib dependency

## QA Results

✅ **QA PASSED** - All acceptance criteria verified:

**Functional Testing:**

- ✅ RabbitMQ consumer service connects and consumes messages successfully
- ✅ Event handlers process feedback and auth events correctly
- ✅ Event schema validation works for all event types
- ✅ Retry logic with exponential backoff functions properly
- ✅ Dead letter queue routing works after max retries
- ✅ Correlation ID generation and tracing implemented
- ✅ Health checks return proper status for RabbitMQ consumer

**Code Quality:**

- ✅ 149/149 tests passing (100% success rate)
- ✅ TypeScript compilation successful with no errors
- ✅ Code follows DDD + CQRS patterns
- ✅ Proper error handling and logging throughout
- ✅ Circuit breaker pattern implemented for external services

**Performance:**

- ✅ Message processing with retry logic performs within acceptable limits
- ✅ Health check endpoints respond quickly
- ✅ No memory leaks detected in consumer service

**Security:**

- ✅ Input validation prevents malformed messages
- ✅ Error messages don't expose sensitive information
- ✅ Proper authentication and authorization patterns followed
